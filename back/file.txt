// models/paieGenerator.js
const db = require('../models/db.js');

// Récupère les agents d'une catégorie donnée
async function getAgentsByCategory(categoryId) {
  const result = await db.query(
    `SELECT id FROM agents WHERE id_categorie = $1`,
    [categoryId]
  );
  return result.rows;
}

// Vérifie si une fiche existe déjà pour un agent à une date donnée
async function ficheExists(agentId, month, year) {
  const result = await db.query(
    `SELECT 1 FROM paies WHERE id_agent = $1 AND mois_paye = $2 AND annee_paye = $3`,
    [agentId, month, year]
  );
  return result.rows.length > 0;
}

// Récupère le chiffre d'affaires d'un agent pour une période donnée
async function getTurnover(agentId, categoryId, month, year) {
  const result = await db.query(
    `SELECT ca.montant
     FROM chiffre_affaire ca
     JOIN agents ON agents.id = ca.id_agent
     WHERE ca.id_agent = $1 AND id_categorie = $2
       AND EXTRACT(MONTH FROM ca.date) = $3
       AND EXTRACT(YEAR FROM ca.date) = $4`,
    [agentId, categoryId, month, year]
  );
  return result.rows.length > 0 ? parseFloat(result.rows[0].montant) : null;
}

// Récupère les données d'un agent
async function getAgentData(agentId) {
  const result = await db.query(
    `SELECT matricule, salaire_base, id_categorie FROM agents WHERE id = $1`,
    [agentId]
  );
  return result.rows[0];
}

// Récupère les données de bonus d'une catégorie
async function getCategoryBonus(categoryId) {
  const result = await db.query(
    `SELECT bonus_pourcentage AS bonus, montant
     FROM categories cat
     JOIN avoir ON avoir.id_categorie = cat.id
     JOIN seuils ON avoir.id_seuil = seuils.id
     WHERE cat.id = $1`,
    [categoryId]
  );
  return result.rows[0];
}

// Insère une fiche de paie dans la base de données
async function insertPaySlip(agentId, matricule, salaireBase, bonus, total, createdDate, mois, annee) {
  await db.query(
    `INSERT INTO paies (date, matricule, salaire_base, bonus, salaire_total, id_agent, mois_paye, annee_paye)
     VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
    [createdDate, matricule, salaireBase, bonus, total, agentId, mois, annee]
  );
}

// Récupère la fiche de paie nouvellement créée pour un agent donné
async function getNewPaySlip(agentId, month, year) {
  const result = await db.query(
    `SELECT p.*, a.nom, a.prenom, c.nom AS categorie, s.montant AS seuil, c.bonus_pourcentage AS pourcentage
     FROM paies p
     JOIN agents a ON a.id = p.id_agent
     JOIN categories c ON a.id_categorie = c.id
     JOIN avoir ON c.id = avoir.id_categorie
     JOIN seuils s ON avoir.id_seuil = s.id
     WHERE p.id_agent = $1 AND p.mois_paye = $2 AND p.annee_paye = $3
     ORDER BY p.date DESC
     LIMIT 1`,
    [agentId, month, year]
  );

  if (result.rows.length === 0) return null;

  const fiche = result.rows[0];

  return {
    matricule: fiche.matricule,
    nom: fiche.nom,
    prenom: fiche.prenom,
    categorie: fiche.categorie,
    seuil: parseFloat(fiche.seuil),
    pourcentage: parseFloat(fiche.pourcentage),
    salaire_base: parseFloat(fiche.salaire_base),
    chiffre_affaire: fiche.salaire_total - fiche.salaire_base - fiche.bonus < 0 ? null : fiche.salaire_total - fiche.salaire_base - fiche.bonus + parseFloat(fiche.bonus),
    bonus: parseFloat(fiche.bonus),
    salaire_total: parseFloat(fiche.salaire_total),
    mois_paye: fiche.mois_paye,
    annee_paye: fiche.annee_paye,
    date_creation: fiche.date,
  };
}

// Génère les fiches pour une catégorie, un mois et une année donnés
exports.generateByCategory = async (categoryId, month, year) => {
  const agents = await getAgentsByCategory(categoryId);

  for (const agent of agents) {
    if (await ficheExists(agent.id, month, year)) continue;

    const turnover = await getTurnover(agent.id, categoryId, month, year);
    if (turnover === null) continue;

    const agentData = await getAgentData(agent.id);
    const categoryData = await getCategoryBonus(categoryId);

    const salaireBase = parseFloat(agentData.salaire_base);
    const seuil = parseFloat(categoryData.montant);
    const pourcentage = parseFloat(categoryData.bonus);

    const difference = turnover - seuil;
    if (difference <= 0) continue;

    const bonus = difference * pourcentage;
    const salaireTotal = bonus + salaireBase;
    const createdDate = new Date();

    await insertPaySlip(agent.id, agentData.matricule, salaireBase, bonus, salaireTotal, createdDate, month, year);
    await getNewPaySlip(agent.id, month, year); // Optionnel : affichage / log
  }
};

// Génère une fiche individuelle ou retourne celle existante
exports.generateForAgent = async (agentId, mois, annee) => {
  const agentData = await getAgentData(agentId);
  if (!agentData) throw new Error("Agent introuvable");

  const { matricule, salaire_base, id_categorie } = agentData;
  const salaireBase = parseFloat(salaire_base);

  const existing = await ficheExists(agentId, mois, annee);
  if (existing) {
    return await getNewPaySlip(agentId, mois, annee);
  }

  const chiffreAffaire = await getTurnover(agentId, id_categorie, mois, annee);
  if (chiffreAffaire === null) {
    throw new Error("Pas de chiffre d'affaire disponible pour cette période");
  }

  const categoryData = await getCategoryBonus(id_categorie);
  const seuil = parseFloat(categoryData.montant);
  const pourcentage = parseFloat(categoryData.bonus);

  const difference = chiffreAffaire - seuil;
  const bonus = difference > 0 ? difference * pourcentage : 0;
  const salaireTotal = salaireBase + bonus;
  const createdDate = new Date();

  await insertPaySlip(agentId, matricule, salaireBase, bonus, salaireTotal, createdDate, mois, annee);
  return await getNewPaySlip(agentId, mois, annee);
};

// Récupère toute la table paie
exports.getAll = async () => {
  const result = await db.query(`
    SELECT p.matricule, a.nom, a.prenom, p.salaire_total as salaire, p.mois_paye as mois, p.annee_paye as annee
    FROM paies p
    JOIN agents a ON a.id = p.id_agent
    ORDER BY p.date DESC
  `);

  const AllpaySlip = {};
  result.rows.forEach(item => {
    AllpaySlip[item.nom] = item;
  });

  return AllpaySlip;
};

// Filtrage des fiches de paie
exports.getPaySlipByFilter = async (matricule, categorieId, mois, annee) => {
  let filters = [];
  let values = [];
  let index = 1;

  if (matricule) {
    filters.push(`p.matricule = $${index++}`);
    values.push(matricule);
  }

  if (categorieId) {
    filters.push(`c.id = $${index++}`);
    values.push(categorieId);
  }

  if (mois) {
    filters.push(`p.mois_paye = $${index++}`);
    values.push(mois);
  }

  if (annee) {
    filters.push(`p.annee_paye = $${index++}`);
    values.push(annee);
  }

  const whereClause = filters.length ? `WHERE ${filters.join(' AND ')}` : '';

  const result = await db.query(`
    SELECT p.matricule, a.nom, a.prenom, p.salaire_total AS salaire, p.mois_paye AS mois, p.annee_paye AS annee
    FROM paies p
    JOIN agents a ON a.id = p.id_agent
    JOIN categories c ON a.id_categorie = c.id
    ${whereClause}
    ORDER BY p.date DESC
  `, values);

  const filtered = {};
  result.rows.forEach(item => {
    filtered[item.nom] = item;
  });

  return filtered;
};
